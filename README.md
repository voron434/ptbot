# Документация к ptbot

`ptbot` — модуль для создания Telegram-ботов. Он умеет отправлять сообщения, редактировать ранее отправленные и реагировать на входящие сообщения от пользователя.

## Как установить

#### Установите библиотеки

Вам понадобится библиотека `python-telegram-bot`.

#### Скачайте файл

Скачайте файл [ptbot.py](#file-ptbot-py) и положите рядом со своей программой.

#### <a name="Howto"></a> Отправьте первое сообщение

Пора проверить работу бота. Для этого понадобится немного кода и пара ключей доступа.

Прежде всего вам нужен API ключ. Его можно получить у [Отца ботов](https://telegram.me/botfather) при регистрации нового бота. Введите команду `/newbot` в чате с ним и следуйте инструкциям.

Свяжитесь с ботом. Найдите его в Telegram и отправьте ему любое сообщение. Telegram требует, чтобы пользователь инициировал диалог с ботом и тем самым разрешил боту отправлять себе сообщения.

Узнайте `id` своего пользователя в Telegram, его вам скажет [Бот-справочник](https://telegram.me/userinfobot).

Когда соберете все ключи скопируйте к себе код, поменяйте значения `TOKEN` и `CHAT_ID`, запустите программу. Бот пришлёт вам сообщение в чат:


```python
import ptbot

TOKEN = '958423683:AAEAtJ5Lde5YYfu8GldVhSGCAsxAYbzUIYg'  # подставьте свой ключ API
CHAT_ID = '228593533'  # подставьте свой ID
bot = ptbot.Bot(TOKEN)
bot.send_message(CHAT_ID, "Бот запущен")
```

От бота в Telegram придёт сообщение:

```
Бот запущен
```

## Проблемы

При запуске кода вы можете столкнуться с проблемой `NewConnectionError. Failed to establish a new connection`. В консоли она выглядит так:

```
WARNING:telegram.vendor.ptb_urllib3.urllib3.connectionpool:Retrying (Retry(total=2, connect=None,
read=None, redirect=None)) after connection broken by
'NewConnectionError('<telegram.vendor.ptb_urllib3.urllib3.connection.VerifiedHTTPSConnection object at 0x7f04b2e55550>:
Failed to establish a new connection: [Errno 101] Network is unreachable')': /bot..../sendMessage
```

Такое случается если сервера Telegram заблокированы провайдером. Решается включением VPN. Браузерный VPN здесь не поможет, включите VPN сразу на всю операционную систему. Вот подборка из [10 лучших бесплатных VPN-сервисов](https://lifehacker.ru/free-vpn/).

## <a name="Contents"></a> Другие возможности

- [Отправка сообщения](#-отправка-сообщения)
- [Редактирование сообщения](#-редактирование-сообщения)
- [Запуск бота](#-запуск-бота)
- [Создание таймера](#-создание-таймера)
- [Создание периодического таймера](#-создание-периодического-таймера)
- [Ожидание сообщения пользователя](#-ожидание-сообщения-пользователя)

### <a name="send_message"></a> Отправка сообщения

Вот как можно отправить пользователю сообщение с текстом "Моё сообщение":

```python
import ptbot

bot = ptbot.Bot("Мой токен")  # подставьте свой ключ API
bot.send_message("Мой id чата", "Моё сообщение")
```
> Не забудьте заменить `Мой токен` и `Мой id чата` на свои, подробнее см. [Отправьте первое сообщение](#Howto).

Метод `send_message` возвращает `id` сообщения, только что отправленного пользователю. Зная `id` сообщения вы можете его [редактировать](#-редактирование-сообщения). Как получить `id` :
```python
import ptbot

bot = ptbot.Bot("Мой токен")
message_id = bot.send_message("Мой id чата", "Моё сообщение")
print('ID сообщения', message_id)
```

### <a name="update_message"></a> Редактирование сообщения
```python
import ptbot

bot = ptbot.Bot("Мой токен")
bot.update_message("Мой id чата", "id сообщения", "Новое сообщение")
```
> Не забудьте заменить `Мой токен` и `Мой id чата` на свои, подробнее см. [Отправьте первое сообщение](#Howto).

`id сообщения` тоже нужно заменить. Но его можно получить после [отправки сообщения](#-отправка-сообщения).

### <a name="run_bot"></a> Запуск бота

Этот метод необходим для работы следующих методов:

- [Создание таймера](#-создание-таймера)
- [Создание периодического таймера](#-создание-периодического-таймера)
- [Ожидание сообщения пользователя](#-ожидание-сообщения-пользователя)


Метод `run_bot` ничего не возвращает и, более того, никогда не завершает своей работы. Он вводит программу в "режим ожидания сообщений" и может работать вечно:

```python3
bot = ptbot.Bot("Мой токен")
bot.run_bot()

print("Эта строка кода никогда не запустится")
```
Последняя строчка кода никогда не выведет на экран сообщение из-за этого "режима ожидания". **Всегда вызывайте `run_bot` в конце своей программы.**

### <a name="create_timer"></a> Создание таймера

Этот метод не работает без метода [run_bot](#-запуск-бота).

Метод `create_timer()` создаёт таймер, по истечению которого запустится отложенная задача. Метод требует два аргумента:

1. Сколько секунд ждать
2. Функция-коллбэк, которая запустится через это количество секунд.

Самый простой вариант использования:

```python
import ptbot

def notify():
    print("Функция запустилась!")

bot = ptbot.Bot("Мой токен")
bot.create_timer(5, notify)

bot.run_bot()
```

Здесь, таймер запустится как только вы запустите этот код. Он подождёт 5 секунд и запустит функцию `notify`: в консолько выведется "Функция запустилась!".

Метод `create_timer` умеет передавать в функцию-коллбэк аргументы. Всё что `create_timer` сам получит при вызове он передаст в функцию коллбэк:

```python
import ptbot

def say_name(first_name, last_name):
    print("Привет," , first_name, last_name)
    # Здесь можно ещё писать код

bot = ptbot.Bot("Мой токен")
bot.create_timer(10, say_name, "Витя", "Иванов")

bot.run_bot()
```

Через 10 секунд после запуска кода запустится функция `say_name()` и выведет `Привет, Витя Иванов`.

В отличие от предыдущего примера программа передала в `create_timer()` два дополнительных аргумента — `"Витя"` и `"Иванов"` — и через 10 секунд те попали в функцию `say_name()` в виде аргументов `first_name` и `last_name`.

Тот же код можно записать с помощью именованных аргументов, чтобы было меньше путаницы:

```
bot.create_timer(10, say_name, first_name="Витя", last_name="Иванов")
```

### <a name="create_countdown"></a> Создание периодического таймера

Этот метод не работает без метода [run_bot](#-запуск-бота).

Метод `create_countdown()` умеет вести обратный отсчёт, каждую секунду запуская функцию-коллбэк. Метод требует 2 аргумента:

1. Сколько секунд повторять задачу
2. Функция-коллбэк, которая будет запускаться каждую секунду, пока не выйдет время.

```python
import ptbot

def notify_progress(secs_left):
    print("Осталось секунд:", secs_left)

bot = ptbot.Bot("Мой токен")
bot.create_countdown(5, notify_progress)

bot.run_bot()
```

Этот код каждую секунду будет печатать `Осталось секунд: 5"` в течение 5 секунд:

```
Осталось секунд: 5
Осталось секунд: 4
Осталось секунд: 3
Осталось секунд: 2
Осталось секунд: 1
Осталось секунд: 0
```

Функция-коллбэк должна принимать позиционный аргумент `secs_left`. В него передается число с количеством секунд, что осталось до конца отсчёта.

Подобно [методу create_timer](#create_timer) `create_countdown` может передать в функцию-коллбэк больше аргументов:

```python
import ptbot

def notify_progress(secs_left, name, age):
    print("Привет," , name)
    print("Мне ", age, " лет")

bot = ptbot.Bot("Мой токен")
bot.create_countdown(10, notify_progress, "Витя", 7)

bot.run_bot()
```

Мы передали в `.create_countdown()` лишние аргументы: `"Витя"` и `7`. Они передались в функцию `notify_progress()` в переменные `name` и `age`.

В течение 10 секунд каждую секунду будет запускаться функция `notify_progress()` и выводить `Привет, Витя Мне 7 лет`.

### <a name="reply_on_message"></a> Ожидание сообщения пользователя

Метод `reply_on_message()` говорит боту что делать, если ему напишет человек. Он принимает на вход функцию-коллбэк, которую бот сам запустит, как только получит сообщение. Первым аргументом он передаст ей текст сообщения от пользователя.

```python
import ptbot

def reply(text):
    print("Привет! Ты написал мне: ", text)

bot = ptbot.Bot("Мой токен")
bot.reply_on_message(reply)

bot.run_bot()
```

Если пользователь напишет боту `Ты ждешь?` , то тот выведет в треминал `Привет! Ты написал мне: Ты ждешь?`.

Внутри функции `def reply(text):` можно свободно дописывать любой код. Название у функции тоже можно менять. Вот несколько примеров:

```python
def log_all_messages(text):
    print("Получил сообщение от пользователя.", text)

bot = ptbot.Bot("Мой токен")
bot.reply_on_message(log_all_messages)

bot.run_bot()
```

```python
def say_hello(text):
    message_id = bot.send_message("id чата", "Привет! Я здесь, я работаю!")
    print('Я отправил сообщение #', message_id)

bot = ptbot.Bot("Мой токен")
bot.reply_on_message(say_hello)

bot.run_bot()
```

Метод `reply_on_message` умеет передавать в функцию-коллбэк дополнительные аргументы помимо обязательного `text`. Все, что вы укажите при вызове `reply_on_message` после функции-коллбэка попадёт в этот коллбэк:


```python
def log_all_messages(text, chat_id):
    print('Получил входящее сообщение')
    print('Id чата:', chat_id)

bot = ptbot.Bot("Мой токен")
chat_id = "id чата"
bot.reply_on_message(log_all_messages, chat_id)

bot.run_bot()
```
